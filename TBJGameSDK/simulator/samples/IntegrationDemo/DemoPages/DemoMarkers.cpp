// DemoMarkers.cpp
// Copyright (C) 2010 Audiokinetic Inc
/// \file 
/// Defines the methods declared in DemoMarkers.h.

#include "stdafx.h"

#include <AK/SoundEngine/Common/AkSoundEngine.h>    // Sound engine

#include "../WwiseProject/GeneratedSoundBanks/Wwise_IDs.h"		// IDs generated by Wwise
#include "Menu.h"
#include "Helpers.h"
#include "DemoMarkers.h"
#include "Platform.h"

/////////////////////////////////////////////////////////////////////
// DemoMarkers Constant Member Initialization
/////////////////////////////////////////////////////////////////////

// We start writing the text at 1/4 the width of the screen. We want
// a 1/8 margin on the right, so let's wrap at 5/8 of the width:
#define DEMO_MARKERS_MAX_CAPTION_WIDTH (INTEGRATIONDEMO_SCREEN_CHAR_WIDTH * 5 / 8 )

const char* DemoMarkers::SUBTITLES[] =
{
	"",
	"In this tutorial...",
	"...we will look at creating...",
	"...actor-mixers...",
	"...and control buses.",
	"We will also look at the...",
	"...actor-mixer and master-mixer structures...",
	"...and how to manage these structures efficiently."
};


/////////////////////////////////////////////////////////////////////
// DemoMarkers Public Methods
/////////////////////////////////////////////////////////////////////

DemoMarkers::DemoMarkers( Menu& in_ParentMenu ):Page( in_ParentMenu, "Subtitles/Markers Demo" )
{
	m_szHelp  = "This demo shows how to use markers in WAV files to "
				"synchronize subtitles with the audio track. Press the "
				"\"Play Markers\" button to hear the sound and see "
				"markers as they are triggered.";

	for ( int i = 0; i < (NUM_LINES+1); i++ )
	{
		m_subtitles[i] = IntegrationDemoHelpers::WordWrapString( SUBTITLES[i], DEMO_MARKERS_MAX_CAPTION_WIDTH );
	}
}

bool DemoMarkers::Init()
{
	// Load the sound bank
	AkBankID bankID; // Not used
	if ( AK::SoundEngine::LoadBank( "MarkerTest.bnk", AK_DEFAULT_POOL_ID, bankID ) != AK_Success )
	{
		SetLoadFileErrorMessage( "MarkerTest.bnk" );
		return false;
	}

	// Register the "Markers" game object
	AK::SoundEngine::RegisterGameObj( GAME_OBJECT_NARRATOR, "Narrator" );

	// Initialize the marker playback variables
	m_unCurrentLine = 0;
	m_bPlayingMarkers = false;
	
	// Initialize the page
	return Page::Init();
}

void DemoMarkers::Release()
{
	// Make sure we do not get called back after page destruction
	AK::SoundEngine::CancelEventCallback( m_iPlayingID );

	// Stop the sound playing
	AK::SoundEngine::StopPlayingID( m_iPlayingID );

	// Unregister the "Markers" game object
	AK::SoundEngine::UnregisterGameObj( GAME_OBJECT_NARRATOR );

	// Unload the sound bank
	AK::SoundEngine::UnloadBank( "MarkerTest.bnk", NULL );

	// Releases the page
	Page::Release();
}

void DemoMarkers::Draw()
{
	Page::Draw();

	if ( m_bPlayingMarkers )
	{
		AkTimeMs uPosition;
		char strBuf[50];
		int iPosX = m_pParentMenu->GetWidth() / 4;
		int iPosY = m_pParentMenu->GetHeight() / 3;
		int iSubX = m_pParentMenu->GetWidth() / 4;
		int iSubY = m_pParentMenu->GetHeight() / 2;

		// Get the current play position and store it in a string buffer
		AK::SoundEngine::GetSourcePlayPosition( m_iPlayingID, &uPosition );
		snprintf( strBuf, 50, "Time: %d ms", (int)uPosition );

		// Draw the play position and subtitles
		DrawTextOnScreen( strBuf, iPosX, iPosY );
		DrawTextOnScreen( m_subtitles[m_unCurrentLine].c_str(), iSubX, iSubY, DrawStyle_Text );
	}
}


/////////////////////////////////////////////////////////////////////
// DemoMarkers Private Methods
/////////////////////////////////////////////////////////////////////

void DemoMarkers::InitControls()
{
	ButtonControl* newBtn;

	// Create the "Play Markers" button
	newBtn = new ButtonControl( *this );
	newBtn->SetLabel( "Play Markers" );
	newBtn->SetDelegate( (PageMFP)&DemoMarkers::PlayMarkersButton_Pressed );
	m_Controls.push_back( newBtn );
}

void DemoMarkers::PlayMarkersButton_Pressed( void* in_pSender, ControlEvent* )
{
	ButtonControl* sender = (ButtonControl*)in_pSender;

	if ( !m_bPlayingMarkers )
	{
		m_bPlayingMarkers = true;
		sender->SetLabel( "--Playing--" );

		// Post the PLAY_MARKERS_TEST event and ask for marker event notifications
		m_iPlayingID = AK::SoundEngine::PostEvent( 
			AK::EVENTS::PLAY_MARKERS_TEST,
			GAME_OBJECT_NARRATOR,
			AK_EndOfEvent | AK_Marker | AK_EnableGetSourcePlayPosition,
			&DemoMarkers::MarkersCallback,
			this
			);

	}
}

void DemoMarkers::MarkersCallback( AkCallbackType in_eType, AkCallbackInfo* in_pCallbackInfo )
{
	DemoMarkers* pPage = (DemoMarkers*)in_pCallbackInfo->pCookie;
	if ( in_eType == AK_Marker )
	{
		AkMarkerCallbackInfo* pMarkerCallbackInfo = (AkMarkerCallbackInfo*)in_pCallbackInfo;

		pPage->m_unCurrentLine = pMarkerCallbackInfo->uIdentifier;
		if ( pPage->m_unCurrentLine >= IntegrationDemoHelpers::AK_ARRAYSIZE( DemoMarkers::SUBTITLES ) )
		{	
			pPage->m_unCurrentLine = 0;
		}
	}
	else if ( in_eType == AK_EndOfEvent )
	{
		pPage->m_Controls[0]->SetLabel( "Play Markers" );
		pPage->m_bPlayingMarkers = false;
		pPage->m_unCurrentLine = 0;
	}
	else
	{
		pPage->SetErrorMessage( "Unsupported event occurred" );
	}
}
